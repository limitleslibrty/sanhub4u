<!DOCTYPE html>
<html> 
<head>
  <meta charset="utf-8">
  <title>User feedback</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100dvh; font-family: Arial, sans-serif; }

    
    #start, #chat { display: none; height: 100%; width: 100%; }
    #start.active, #chat.active { display: flex; flex-direction: column; }
    #start { justify-content: center; align-items: center; background: #ece5dd; }
    #start input, #start button {
      padding: 10px; font-size: 16px; border-radius: 8px;
      width: 80%; max-width: 300px; margin-top: 10px;
      border: 1px solid #ccc;
    }
    #start button { background: #075E54; color: white; border: none; }

#chatHeader {
  position: fixed;   /* pin to viewport */
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background: #FFFFFF;
  color: #191818;
  padding: 4px 8px;
  font-size: 19px;
  display: flex;
  align-items: center;
  height: 60px;
  border-bottom: 1px solid #ccc;
  /* ensure transforms behave smoothly */
  will-change: transform;
}


    
    #chatHeader img { margin-left: 8px; border-radius: 50%; height: 50px; width: 50px; }
    #chatHeader #chatTitle {
      margin-top: 14px;
      margin-left: 12px; font-weight: 500; }

/* media image/gif style */
img.msg-media{
  max-width:260px;
  max-height:260px;
  border-radius:8px;
  display:block;
  margin-bottom:6px;
}
#gifModal{
  position:fixed;left:0;right:0;top:0;bottom:0;display:none;
  align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:9999;
}
#gifModal .panel{width:92%;max-width:720px;background:#fff;border-radius:12px;padding:10px;max-height:80vh;overflow:auto;}
#gifResults{display:flex;flex-wrap:wrap;gap:8px;}
#gifResults img{width:120px;height:90px;object-fit:cover;border-radius:8px;cursor:pointer;}
    /* Dark mode base */
body.dark {
  background: #121212;
  color: #e0e0e0;
}

/* Chat background */
body.dark #messages {
  background: #0b141a;
  background-image: none; /* hide chat.png if you want */
}

/* Chat header */
body.dark #chatHeader {
  background: #1f2c34;
  color: #e0e0e0;
  border-bottom: 1px solid #333;
}

/* Input area */
body.dark #inputArea {
  background: #1f2c34;
  border-top: 1px solid #333;
}
body.dark #inputRow input {
  background: #2a3942;
  color: #fff;
  border: 1px solid #333;
}
body.dark #inputRow button {
  background: #075E54;
}

/* Bubbles */
body.dark .from-user {
  background: #056162;
  color: #fff;
}
body.dark .from-brother {
  background: #262d31;
  color: #fff;
}

/* Date divider */
body.dark .date-divider {
  background: #2a3942;
  color: #ccc;
}


/* Message time text */
body.dark .msg-time {
  color: #aaa; /* lighter gray for visibility */
}

/* Reply snippet inside bubbles */
body.dark .reply-snippet {
  background: rgba(255, 255, 255, 0.1);
  border-left: 4px solid #34b7f1; /* WhatsApp-like cyan */
  color: #ddd;
}



/* Dark Mode Toggle - Premium Style */
/* Premium Toggle Base */
#darkToggle {
  margin-top: 14px;
  margin-left: auto;
  margin-right: 25px;
  width: 50px;
  height: 26px;
  background: linear-gradient(145deg, #e0e0e0, #ffffff);
  border-radius: 50px;
  position: relative;
  cursor: pointer;
  transition: all 0.4s ease;
  border: 1px solid #ccc;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.1), 0 2px 5px rgba(0,0,0,0.2);
}

/* Circle inside toggle */
#darkToggle::before {
  content: "‚òÄÔ∏è";
  position: absolute;
  top: 2px;
  left: 2px;
  width: 22px;
  height: 22px;
  background: #fff;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.4s ease;
  box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

/* Active Dark Mode (more premium look) */
body.dark #darkToggle {
  background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
  border: 1px solid #444;
  box-shadow: inset 0 0 10px rgba(0, 255, 170, 0.3), 0 0 8px rgba(0, 255, 170, 0.4);
}

/* Move circle to right and glow */
body.dark #darkToggle::before {
  left: 26px;
  background: #222;
  color: #00ff99; /* neon green moon */
  content: "üåô";
  box-shadow: 0 0 6px rgba(0, 255, 170, 0.8), 0 0 12px rgba(0, 255, 170, 0.6);
}


/* Optional: subtle glow when hovered */
#darkToggle:hover {
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}

#darkToggle::before {
  content: var(--toggle-icon, "‚òÄÔ∏è");
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
}

    
    .bubble {
      margin: 6px 0; padding: 10px 15px; border-radius: 8px;
      max-width: 70%; position: relative; word-wrap: break-word;
      display: flex; flex-direction: column;
      transition: transform 0.2s ease;
      will-change: transform;
    }
    .from-user { background: #dcf8c6; align-self: flex-end; }
    .from-brother { background: #fff; align-self: flex-start; }

    .reply-snippet {
      background: rgba(0, 0, 0, 0.05);
      border-left: 4px solid #075E54;
      padding: 5px 10px;
      font-size: 13px;
      margin-bottom: 5px;
      color: #333;
      border-radius: 4px;
    }

  #replyBox {
  display: none;
  background: #f1f0f0;
  padding: 5px 10px;
  border-left: 4px solid #075E54;
  margin: 5px 10px;
  font-style: italic;
  font-size: 14px;
  align-items: center;
  justify-content: space-between;
}

body.dark #replyBox {
  background: #2a3942;
  border-left: 4px solid #34b7f1;
  color: #fff;
}

    #messages {
  position: absolute;
  top: 60px;         /* below header (match header height) */
  left: 0;
  right: 0;
  bottom: 70px;      /* above input area (match its height) */
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  padding: 10px;
  -webkit-overflow-scrolling: touch;
}

#inputArea {
  position: fixed;   /* stick to bottom */
  left: 0;
  right: 0;
  bottom: 0;
  background: #fff;
  border-top: 1px solid #ccc;
  padding: 10px;
  display: flex;
  flex-direction: column;
}
    #inputRow { display: flex; }
    #inputRow input {
      flex: 1; padding: 8px 12px; border: 1px solid #ccc; border-radius: 20px;
    }
    #inputRow button {
      margin-left: 10px; padding: 8px 16px; background: #075E54;
      color: #fff; border: none; border-radius: 20px;
    }

    .msg-time {
      font-size: 10px;
      color: #555;
      margin-top: 4px;
      align-self: flex-end;
    }
    
    body {
  background: #D7D7D7; /* or any color/gradient/image */
}

    .reply-indicator {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.2s;
      color: #075E54;
    }
    .from-user .reply-indicator { left: -25px; }
    .from-brother .reply-indicator { right: -25px; }

    /* Date Divider */
    .date-divider {
      align-self: center;
      background: #d3d3d3;
      color: #333;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      margin: 10px 0;
    }
    
    #msgInput {
  font-family: inherit;
  font-size: 14px;
  line-height: 1.4;
  overflow-y: auto;
}

/* Dark mode */
body.dark #msgInput {
  background: #2a3942; /* dark gray-blue */
  color: #e0e0e0;      /* light text */
  border: 1px solid #333; /* darker border */
}

/* Placeholder color for dark mode */
body.dark #msgInput::placeholder {
  color: #aaa;
}

  </style>
</head>
<body>
  <div id="start" class="active">
    <input id="emailInput" placeholder="Enter your email..." />
    <input id="passInput" placeholder="Enter password..." type="password" />
    <button onclick="startChat()">Enter</button>
  </div>

  <div id="chat">
    <div id="chatHeader">
      <img src="chat_logo.png" alt="logo" />
      <b><div 
      id="chatTitle">BaBuüòò</div></b>
      
      
  <span id="statusIndicator" style="font-size:15px;
  margin-top: 15.5px;
  margin-left:8px;"></span>
<span id="darkToggle" style="margin-left:auto;
margin-right: 25px;
background:none; border:none; font-size:25px; cursor:pointer;"></span>
      
      
    </div>

    <div id="messages"></div>

    <div id="inputArea">
<div id="replyBox">
  <span id="replyText"></span>
  <button id="closeReply">
    ‚úï
  </button>
</div>

      <div id="inputRow">
<textarea id="msgInput" placeholder="Type a message‚Ä¶" rows="1" ...></textarea>
<button id="gifBtn" type="button" onclick="openGifModal()">GIF</button>
<input type="file" id="imgInput" accept="image/*" style="display:none;" onchange="sendImage(event)">
<button onclick="document.getElementById('imgInput').click()">üì∑</button>
<button onclick="sendMessage()">Send</button>
      </div>
    </div>
  </div>
<!-- GIF modal -->
<div id="gifModal" aria-hidden="true">
  <div class="panel" role="dialog" aria-modal="true">
    <div style="display:flex;gap:8px;margin-bottom:8px;">
      <input id="gifQuery" placeholder="Search GIFs (GIPHY)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ccc" />
      <button id="gifSearchBtn" onclick="searchGiphy()">Search</button>
      <button id="gifCloseBtn" onclick="closeGifModal()">Close</button>
    </div>
    <div id="gifResults">Type a query and press Search or click Close.</div>
  </div>
</div>
  <script>
/* =========================
   Firebase + DOM handles
   ========================= */
const db = firebase.database();
const startEl    = document.getElementById('start');
const chatEl     = document.getElementById('chat');
const messagesEl = document.getElementById('messages');
const msgInput   = document.getElementById('msgInput');
const emailInput = document.getElementById('emailInput');
const passInput  = document.getElementById('passInput');
const replyBox   = document.getElementById('replyBox');
// --- GIF config: set your GIPHY API key (get one at developers.giphy.com)
const GIPHY_API_KEY = "e68mngd8xYdq05iTwWRZPlbK92CIPhMB"; // replace if you have your own key
const FRIEND_KEY = 'brother'; // set your peer's id/name used in DB (case-insensitive)

let userKey = '';
let replyTo = null;
let messageListener = null;
let messageMap = {};           // key -> message
let lastDateForDivider = '';

/* =========================
   Presence
   ========================= */
function trackPresence() {
  if (!userKey) return;
  const userStatusRef = db.ref('status/' + userKey);
  db.ref('.info/connected').on('value', snap => {
    if (snap.val() === true) {
      userStatusRef.onDisconnect().set({ state: 'offline', last_changed: Date.now() });
      userStatusRef.set({ state: 'online', last_changed: Date.now() });
    }
  });
}
let typingTimeout;

msgInput.addEventListener("input", () => {
  if (!userKey) return;
  
  // Mark typing
  db.ref("status/" + userKey).update({ typing: true });
  
  // Reset typing after 2s of no input
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    db.ref("status/" + userKey).update({ typing: false });
  }, 2000);
});

// When input loses focus, stop typing
msgInput.addEventListener("blur", () => {
  if (userKey) {
    db.ref("status/" + userKey).update({ typing: false });
  }
});
function listenToStatus(friendKey) {
  const statusIndicator = document.getElementById("statusIndicator");
  
  db.ref("status/" + friendKey).on("value", (snapshot) => {
    const status = snapshot.val();
    
    // Debug log
    console.log("Status snapshot for", friendKey, status);
    
    if (!status) {
      statusIndicator.textContent = "‚óè Offline";
      statusIndicator.style.color = "gray";
      return;
    }
    
    if (status.typing === true) {
      statusIndicator.textContent = "typing...";
      statusIndicator.style.color = "dodgerblue";
    } else if (status.state === "online") {
      statusIndicator.textContent = "‚óè Online";
      statusIndicator.style.color = "limegreen";
    } else if (status.state === "offline") {
      statusIndicator.textContent = "last seen " + formatLastSeen(status.last_changed);
      statusIndicator.style.color = "gray";
    } else {
      statusIndicator.textContent = "‚óè Unknown";
      statusIndicator.style.color = "red";
    }
  });
}
/* =========================
   Auth-ish gate
   ========================= */
window.onload = function() {
  const savedEmail = localStorage.getItem('userEmail');
  if (savedEmail) {
    userKey = savedEmail.replace(/\./g, '_');
    startEl.classList.remove('active');
    chatEl.classList.add('active');
    loadMessages();
    trackPresence();
    
    const pass = prompt("Enter your password:");
    if (pass !== "mahi@123") {
      alert("Incorrect password!");
      localStorage.removeItem('userEmail');
      startEl.classList.add('active');
      chatEl.classList.remove('active');
    }
    
    // ‚úÖ call here so DOM is ready
    listenToStatus(FRIEND_KEY);
    
  } else {
    startEl.classList.add('active');
    chatEl.classList.remove('active');
  }
};

function startChat() {
  const email = emailInput.value.trim();
  const pass = passInput.value.trim();
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailPattern.test(email)) { alert('Please enter a valid email'); return; }
  if (pass !== 'mahi@123') { alert('Incorrect password!'); return; }
  localStorage.setItem('userEmail', email);
  userKey = email.replace(/\./g, '_');
  startEl.classList.remove('active');
  chatEl.classList.add('active');
  loadMessages();
  trackPresence();
}

/* =========================
   Load last 50 + stream new
   ========================= */
function loadMessages() {
  // reset UI state
  messagesEl.innerHTML = '';
  messageMap = {};
  lastDateForDivider = '';

  // stop any prior listener
  if (messageListener) messageListener.off();

  // Use orderByKey since your keys are Date.now() timestamps (strings).
  const listRef = db.ref('chats/' + userKey).orderByKey().limitToLast(50);

  listRef.once('value', snapshot => {
    const msgs = [];
    snapshot.forEach(child => msgs.push({ key: child.key, ...child.val() }));

    // Ensure correct chronological order
    msgs.sort((a,b) => Number(a.key) - Number(b.key));

    msgs.forEach(m => addSingleMessage(m));
    scrollToBottom();

    const lastKey = msgs.length ? msgs[msgs.length - 1].key : '0';

    // Now listen for *newer* items. startAt(lastKey) will also emit the last item once;
    // our messageMap guard prevents duplicates.
    messageListener = db.ref('chats/' + userKey).orderByKey().startAt(lastKey);
    messageListener.on('child_added', snap => {
      const msg = { key: snap.key, ...snap.val() };
      if (messageMap[msg.key]) return; // skip already rendered
      addSingleMessage(msg);
      scrollToBottom();
    });
  });
}
/**
 * Compress an Image/File/Blob to a JPEG dataURL under maxKB (200 KB default).
 * Returns a Promise that resolves to a dataURL string.
 */
function compressImageFile(fileOrBlob, maxKB = 200, maxWidth = 1280, maxHeight = 1280) {
  return new Promise((resolve, reject) => {
    // read file/blob as dataURL
    const reader = new FileReader();
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.onload = () => {
      const img = new Image();
      img.onerror = () => reject(new Error('Invalid image file'));
      img.onload = async () => {
        try {
          // compute target dimensions (fit within maxWidth/maxHeight)
          let [w, h] = [img.naturalWidth, img.naturalHeight];
          const ratio = Math.min(1, maxWidth / w, maxHeight / h);
          w = Math.round(w * ratio);
          h = Math.round(h * ratio);

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img, 0, 0, w, h);

          // helper to get blob from canvas at given quality
          function canvasToBlobPromise(quality) {
            return new Promise(res => {
              canvas.toBlob(blob => res(blob), 'image/jpeg', quality);
            });
          }

          // first try with descending quality
          let quality = 0.92;
          let blob = await canvasToBlobPromise(quality);

          // If already under target, return
          const targetBytes = maxKB * 1024;

          // Decrease quality in steps until target or minQuality
          const minQuality = 0.40;
          while (blob && blob.size > targetBytes && quality > minQuality) {
            quality -= 0.07; // step down
            if (quality < minQuality) quality = minQuality;
            blob = await canvasToBlobPromise(quality);
          }

          // If still too big, progressively shrink dimensions and retry
          let shrinkFactor = 0.9; // reduce to 90% each loop
          while (blob && blob.size > targetBytes && (canvas.width > 300 && canvas.height > 300)) {
            canvas.width = Math.round(canvas.width * shrinkFactor);
            canvas.height = Math.round(canvas.height * shrinkFactor);
            // redraw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            // reset quality a bit
            quality = Math.max(0.85, quality); // try decent quality first
            blob = await canvasToBlobPromise(quality);

            // if still large, reduce quality further
            while (blob && blob.size > targetBytes && quality > minQuality) {
              quality -= 0.07;
              if (quality < minQuality) quality = minQuality;
              blob = await canvasToBlobPromise(quality);
            }
            // loop until under target or image is very small
          }

          // fallback: if nothing worked, use the last blob (best effort)
          if (!blob) return reject(new Error('Compression failed'));

          // convert blob to dataURL
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = () => reject(new Error('Failed to read compressed blob'));
          fr.readAsDataURL(blob);
        } catch (err) {
          reject(err);
        }
      };
      img.src = reader.result;
    };

    // If input is a Blob or File, read it
    reader.readAsDataURL(fileOrBlob);
  });
}

/**
 * Replaces your previous sendImage(event) to compress before sending.
 * Call this on file input change: onchange="sendImage(event)"
 */
function sendImage(event) {
  const file = event.target.files && event.target.files[0];
  if (!file) return;
  const maxKB = 200; // target size in KB

  // Provide UI feedback (optional)
  const originalButton = event.target;
  // compress
  compressImageFile(file, maxKB).then(dataUrl => {
    // payload shape matches your sendMediaMessage usage
    sendMediaMessage({
      type: 'image',
      url: dataUrl,
      filename: file.name
    });
  }).catch(err => {
    console.error('Compression failed', err);
    // fallback: send original as dataURL (may be large) - or notify user
    const reader = new FileReader();
    reader.onload = (ev) => {
      sendMediaMessage({ type: 'image', url: ev.target.result, filename: file.name });
    };
    reader.readAsDataURL(file);
  }).finally(() => {
    // Reset file input so same file can be selected again
    event.target.value = '';
  });
}

/* Update paste handler so pasted image files are compressed before sending */
document.addEventListener('paste', (e) => {
  const items = e.clipboardData && e.clipboardData.items;
  if (!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      // compress then send
      compressImageFile(blob, 200).then(dataUrl => {
        sendMediaMessage({ type: 'image', url: dataUrl });
      }).catch(err => {
        console.error('Paste compression failed', err);
      });
      e.preventDefault();
      return;
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});

// --- VisualViewport-aware layout adaptation (robust, avoid gaps) ---
(function setupViewportAdjustments() {
  const header = document.getElementById('chatHeader');
  const inputArea = document.getElementById('inputArea');
  const messages = document.getElementById('messages');

  // helper to compute current input area height (reflow-safe)
  function getInputHeight() {
    // use offsetHeight (includes padding, border)
    return inputArea.offsetHeight || 70;
  }

  function updateLayout() {
    const vv = window.visualViewport;
    const headerH = header.offsetHeight || 60;
    const inputH = getInputHeight();

    const viewH = vv ? vv.height : window.innerHeight;
    const viewOffsetTop = vv ? vv.offsetTop : 0;

    // keyboard height (0 when keyboard closed)
    const offsetBottom = vv ? Math.max(0, window.innerHeight - (vv.height + vv.offsetTop)) : 0;

    // place inputArea just above keyboard
    inputArea.style.bottom = offsetBottom + "px";

    // pin messages between header and input (avoid using fixed height)
    messages.style.top = headerH + 'px';
    messages.style.bottom = (inputH + offsetBottom) + 'px';

    // ensure header stays visually pinned if visualViewport shifted (keyboard)
    header.style.transform = `translateY(${viewOffsetTop}px)`;
  }

  // if you have CSS that sets bottom: 70px on #messages, override it via JS above.
  // OPTIONAL: remove any hardcoded bottom in CSS or set it to 0 there.

  // listen for visualViewport and window events
  window.addEventListener('resize', updateLayout);
  window.addEventListener('orientationchange', updateLayout);
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', updateLayout);
    window.visualViewport.addEventListener('scroll', updateLayout);
  }

  // auto-grow support: if the textarea changes size, recalc layout
  // (also makes sure expanding textarea doesn't create a gap)
  msgInput.addEventListener('input', () => {
    // simple auto-grow
    msgInput.style.height = 'auto';
    msgInput.style.height = (msgInput.scrollHeight) + 'px';
    setTimeout(updateLayout, 0);
  });

  // also update on focus/blur to react to keyboard
  msgInput.addEventListener('focus', () => {
    setTimeout(() => { updateLayout(); scrollToBottom(); }, 50);
  });
  msgInput.addEventListener('blur', () => {
    setTimeout(updateLayout, 50);
  });

  // initial layout
  setTimeout(updateLayout, 50);

  // expose for debugging if needed
  window.__chatUpdateLayout = updateLayout;
})();
/* =========================
   Sending messages
   ========================= */
function sendMessage() {
  const raw = msgInput.value.trim();
  if (raw === '') return;
  
  const isMediaUrl = raw.match(/^https?:\/\/.*\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || raw.includes('giphy.com');
  
  const key = String(Date.now());
  const base = {
    sender: userKey,
    from: 'user',
    to: FRIEND_KEY,
    time: Number(key),
    replyTo: replyTo ? replyTo.key : null
  };
  
  if (isMediaUrl) {
    // send as media message
    const msg = Object.assign({}, base, { type: 'gif', url: raw });
    db.ref('chats/' + userKey).child(key).set(msg);
  } else {
    const newMsg = Object.assign({}, base, { text: raw });
    db.ref('chats/' + userKey).child(key).set(newMsg);
  }
  
  msgInput.value = '';
  msgInput.style.height = '40px';
  replyTo = null;
  replyBox.style.display = 'none';
  msgInput.focus();
}

// --- GIF modal controls ---
function openGifModal(){
  document.getElementById('gifModal').style.display = 'flex';
  document.getElementById('gifResults').innerHTML = '';
  document.getElementById('gifQuery').value = '';
  document.getElementById('gifQuery').focus();
}
function closeGifModal(){ document.getElementById('gifModal').style.display = 'none'; }

// --- Search GIPHY and render thumbnails ---
async function searchGiphy(){
  const q = (document.getElementById('gifQuery').value || '').trim();
  if(!q) return;
  const results = document.getElementById('gifResults');
  results.innerHTML = 'Loading‚Ä¶';
  try {
    const url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(q)}&limit=24&rating=pg`;
    const res = await fetch(url);
    const json = await res.json();
    results.innerHTML = '';
    (json.data || []).forEach(g => {
      const thumb = g.images && (g.images.fixed_width_small || g.images.fixed_width);
      const full = g.images && (g.images.original || g.images.fixed_width);
      if (!thumb) return;
      const img = document.createElement('img');
      img.src = thumb.url;
      img.alt = g.title || 'gif';
      img.addEventListener('click', () => {
        // send media message with full URL when selected
        const mediaUrl = (full && full.url) ? full.url : thumb.url;
        sendMediaMessage({ type: 'gif', url: mediaUrl });
        closeGifModal();
      });
      results.appendChild(img);
    });
    if((json.data||[]).length === 0) results.innerHTML = 'No GIFs found.';
  } catch (err) {
    console.error(err);
    results.innerHTML = 'Search failed.';
  }
}

// --- Helper to send media message objects ---
function sendMediaMessage(payload){
  if (!userKey) { alert('Open chat first'); return; }
  const key = String(Date.now());
  const msg = {
    sender: userKey,
    from: 'user',
    to: FRIEND_KEY,
    time: Number(key),
    type: payload.type || 'image',
    url: payload.url || payload.mediaUrl || '',
    replyTo: replyTo ? replyTo.key : null
  };
  db.ref('chats/' + userKey).child(key).set(msg);
}
/* =========================
   Rendering helpers
   ========================= */
function addSingleMessage(msg) {
  const ts = Number(msg.time || msg.key);
  const msgDate = new Date(ts).toDateString();

  if (msgDate !== lastDateForDivider) {
    addDateDivider(msgDate);
    lastDateForDivider = msgDate;
  }
  addBubble(msg);
}

function addDateDivider(dateStr) {
  const div = document.createElement('div');
  div.className = 'date-divider';
  const today = new Date().toDateString();
  const yesterday = new Date(Date.now() - 86400000).toDateString();
  if (dateStr === today) div.innerText = "Today";
  else if (dateStr === yesterday) div.innerText = "Yesterday";
  else div.innerText = dateStr;
  messagesEl.appendChild(div);
}

function isFromMe(m) {
  // Primary rule: explicit sender id
  if (m.sender) return m.sender === userKey;

  // Fallback for older rows that only had "from"
  const f = (m.from || '').toString().toLowerCase();
  if (f === 'user') return true;                    // was "me" on this device
  if (f === FRIEND_KEY.toLowerCase()) return false; // explicit peer
  return false; // default to "received" if unknown
}

function addBubble(data) {
  const div = document.createElement('div');
  const mine = isFromMe(data);
  div.classList.add('bubble', mine ? 'from-user' : 'from-brother');
  
  // reply snippet if present
  if (data.replyTo && messageMap[data.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.classList.add('reply-snippet');
    replyDiv.innerText = messageMap[data.replyTo].text || '[' + (messageMap[data.replyTo].type || 'media') + ']';
    div.appendChild(replyDiv);
  }
  
  // If message contains media (gif/image) show image
  if (data.type === 'gif' || data.type === 'image' || data.url) {
    const media = document.createElement('img');
    media.className = 'msg-media';
    media.src = data.url || data.mediaUrl || '';
    media.alt = data.type || 'media';
    // error fallback text node
    media.addEventListener('error', () => {
      const err = document.createElement('div');
      err.style.fontSize = '12px';
      err.style.color = '#b00';
      err.textContent = '[Unable to load media]';
      div.insertBefore(err, media.nextSibling);
    });
    div.appendChild(media);
    if (data.text) {
      const textDiv = document.createElement('div');
      textDiv.innerText = data.text;
      div.appendChild(textDiv);
    }
  } else {
    // regular text-only message
    const textDiv = document.createElement('div');
    textDiv.innerText = data.text || '';
    div.appendChild(textDiv);
  }
  
  const timeDiv = document.createElement('div');
  timeDiv.className = 'msg-time';
  const ts = Number(data.time || data.key);
  timeDiv.textContent = new Date(ts).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true });
  div.appendChild(timeDiv);
  
  const indicator = document.createElement('div');
  indicator.className = 'reply-indicator';
  indicator.innerHTML = '&#8617;';
  div.appendChild(indicator);
  addSwipeListeners(div, data, indicator);
  
  messagesEl.appendChild(div);
  messageMap[data.key] = data;
}

function addSwipeListeners(element, msgData, indicator) {
  let startX=0,startY=0,currentX=0,isDragging=false;
  const threshold=70;
  element.addEventListener("touchstart",e=>{
    startX=e.touches[0].clientX;
    startY=e.touches[0].clientY;
    isDragging=true;
    element.style.transition="none";
  });
  element.addEventListener("touchmove",e=>{
    if(!isDragging)return;
    currentX=e.touches[0].clientX;
    let diffX=currentX-startX;
    let diffY=e.touches[0].clientY-startY;
    if(Math.abs(diffY)>40)return;
    element.style.transform=`translateX(${diffX}px)`;
    indicator.style.opacity=Math.abs(diffX)>30?"1":"0";
  });
  element.addEventListener("touchend",()=>{
    isDragging=false;
    element.style.transition="transform 0.25s ease";
    indicator.style.opacity="0";
    let diffX=currentX-startX;
    if(Math.abs(diffX)>threshold){ setReply(msgData); if(navigator.vibrate)navigator.vibrate(20); }
    element.style.transform="translateX(0)";
  });
}

function setReply(msg) {
  replyTo = msg;
  document.getElementById('replyText').innerText = "Replying to: " + (msg.text || '');
  replyBox.style.display = 'flex';
}
document.getElementById('closeReply').addEventListener('click', () => {
  replyTo = null;
  replyBox.style.display = 'none';
});

function scrollToBottom() {
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

// ‚úÖ Mobile keyboard fix: keep input visible when typing
msgInput.addEventListener("focus", () => {
  setTimeout(() => {
    scrollToBottom();
  }, 300); // wait for keyboard animation
});

// --- VisualViewport-aware layout adaptation ---
// Keeps header visually pinned and resizes messages area when keyboard opens (iOS/Android)
// --- VisualViewport-aware layout adaptation ---
// Keeps header pinned and inputArea above the keyboard (iOS/Android)
// --- VisualViewport-aware layout adaptation (robust, avoid gaps) ---
(function setupViewportAdjustments() {
  const header = document.getElementById('chatHeader');
  const inputArea = document.getElementById('inputArea');
  const messages = document.getElementById('messages');

  // helper to compute current input area height (reflow-safe)
  function getInputHeight() {
    // use offsetHeight (includes padding, border)
    return inputArea.offsetHeight || 70;
  }

  function updateLayout() {
    const vv = window.visualViewport;
    const headerH = header.offsetHeight || 60;
    const inputH = getInputHeight();

    const viewH = vv ? vv.height : window.innerHeight;
    const viewOffsetTop = vv ? vv.offsetTop : 0;

    // keyboard height (0 when keyboard closed)
    const offsetBottom = vv ? Math.max(0, window.innerHeight - (vv.height + vv.offsetTop)) : 0;

    // place inputArea just above keyboard
    inputArea.style.bottom = offsetBottom + "px";

    // pin messages between header and input (avoid using fixed height)
    messages.style.top = headerH + 'px';
    messages.style.bottom = (inputH + offsetBottom) + 'px';

    // ensure header stays visually pinned if visualViewport shifted (keyboard)
    header.style.transform = `translateY(${viewOffsetTop}px)`;
  }

  // if you have CSS that sets bottom: 70px on #messages, override it via JS above.
  // OPTIONAL: remove any hardcoded bottom in CSS or set it to 0 there.

  // listen for visualViewport and window events
  window.addEventListener('resize', updateLayout);
  window.addEventListener('orientationchange', updateLayout);
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', updateLayout);
    window.visualViewport.addEventListener('scroll', updateLayout);
  }

  // auto-grow support: if the textarea changes size, recalc layout
  // (also makes sure expanding textarea doesn't create a gap)
  msgInput.addEventListener('input', () => {
    // simple auto-grow
    msgInput.style.height = 'auto';
    msgInput.style.height = (msgInput.scrollHeight) + 'px';
    setTimeout(updateLayout, 0);
  });

  // also update on focus/blur to react to keyboard
  msgInput.addEventListener('focus', () => {
    setTimeout(() => { updateLayout(); scrollToBottom(); }, 50);
  });
  msgInput.addEventListener('blur', () => {
    setTimeout(updateLayout, 50);
  });

  // initial layout
  setTimeout(updateLayout, 50);

  // expose for debugging if needed
  window.__chatUpdateLayout = updateLayout;
})();
/* =========================
   Utilities
   ========================= */
function formatLastSeen(timestamp) {
  const date = new Date(timestamp), now = new Date();
  const isToday = date.toDateString() === now.toDateString();
  const yesterday = new Date(); yesterday.setDate(yesterday.getDate()-1);
  const time = date.toLocaleTimeString([], {hour:"numeric",minute:"2-digit",hour12:true});
  if (isToday) return "today at " + time;
  else if (date.toDateString() === yesterday.toDateString()) return "yesterday at " + time;
  else return date.toLocaleDateString() + " at " + time;
}

/* =========================
   Dark mode toggle (unchanged)
   ========================= */
if (localStorage.getItem("darkMode") === "enabled") document.body.classList.add("dark");
function updateToggleIcon(){
  const isDark=document.body.classList.contains("dark");
  document.getElementById("darkToggle").style.setProperty("--toggle-icon", `"${isDark?"üåô":"‚òÄÔ∏è"}"`);
}
updateToggleIcon();
darkToggle.addEventListener("click",()=>{
  document.body.classList.toggle("dark");
  localStorage.setItem("darkMode", document.body.classList.contains("dark")?"enabled":"disabled");
  updateToggleIcon();
});

// paste handler: if user pastes an image URL or Giphy link, send as media
document.addEventListener('paste', (e) => {
  const items = e.clipboardData && e.clipboardData.items;
  if(!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      const reader = new FileReader();
      reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
      reader.readAsDataURL(blob);
      e.preventDefault();
      return;
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});
</script>



</body>
</html> 